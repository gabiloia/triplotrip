/*!
 * Built by Revolist OU ❤️
 */
import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-InvwFkCn.js';
import { N as EDIT_INPUT_WR, j as getItemByPosition, b as getSourceItem, O as DRAGG_TEXT } from './dimension.helpers-CIkQtDh8.js';
import { T as TextEditor } from './text-editor-TzgTBSOe.js';
import { m as isEditorCtrConstructible } from './edit.utils-Jiu7iP-o.js';
import { d as debounce } from './debounce-BfO9dz9v.js';

const Clipboard = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.beforePaste = createEvent(this, "beforepaste", 7);
        this.beforePasteApply = createEvent(this, "beforepasteapply", 7);
        this.pasteRegion = createEvent(this, "pasteregion", 7);
        this.afterPasteApply = createEvent(this, "afterpasteapply", 7);
        this.beforeCut = createEvent(this, "beforecut", 7);
        this.clearRegion = createEvent(this, "clearregion", 7);
        this.beforeCopy = createEvent(this, "beforecopy", 7);
        this.beforeCopyApply = createEvent(this, "beforecopyapply", 7);
        this.copyRegion = createEvent(this, "copyregion", 7);
    }
    onPaste(e) {
        // if readonly do nothing
        if (this.readonly) {
            return;
        }
        const clipboardData = this.getData(e);
        const isHTML = ((clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.types.indexOf('text/html')) || -1) > -1;
        const data = (isHTML
            ? clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/html')
            : clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text')) || '';
        const dataText = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text')) || '';
        const beforePaste = this.beforePaste.emit({
            raw: data,
            dataText,
            isHTML,
            event: e,
        });
        if (beforePaste.defaultPrevented) {
            return;
        }
        let parsedData;
        // if html, then search for table if no table fallback to regular text parsing
        if (beforePaste.detail.isHTML) {
            const table = this.htmlParse(beforePaste.detail.raw);
            // fallback to text if not possible to parse as html
            parsedData = table || this.textParse(dataText || '');
        }
        else {
            parsedData = this.textParse(beforePaste.detail.raw);
        }
        const beforePasteApply = this.beforePasteApply.emit({
            raw: data,
            parsed: parsedData,
            event: e,
        });
        if (beforePasteApply.defaultPrevented) {
            return;
        }
        this.pasteRegion.emit(beforePasteApply.detail.parsed);
        // post paste action
        const afterPasteApply = this.afterPasteApply.emit({
            raw: data,
            parsed: parsedData,
            event: e,
        });
        // keep default behavior if needed
        if (afterPasteApply.defaultPrevented) {
            return;
        }
        e.preventDefault();
    }
    /**
     * Listen to copy event and emit copy region event
     */
    copyStarted(e) {
        const beforeCopy = this.beforeCopy.emit({
            event: e,
        });
        if (beforeCopy.defaultPrevented) {
            return;
        }
        const data = this.getData(beforeCopy.detail.event);
        this.copyRegion.emit(data || undefined);
        e.preventDefault();
    }
    /**
     * Listen to copy event and emit copy region event
     */
    cutStarted(e) {
        const beforeCut = this.beforeCut.emit({
            event: e,
        });
        if (beforeCut.defaultPrevented) {
            return;
        }
        const data = this.getData(beforeCut.detail.event);
        this.copyStarted(e);
        // if readonly do nothing
        if (this.readonly) {
            return;
        }
        this.clearRegion.emit(data || undefined);
        e.preventDefault();
    }
    async doCopy(e, data) {
        const beforeCopyApply = this.beforeCopyApply.emit({
            event: e,
            data,
        });
        if (beforeCopyApply.defaultPrevented) {
            return;
        }
        const parsed = data ? this.parserCopy(data) : '';
        e.setData('text/plain', parsed);
    }
    parserCopy(data) {
        return data.map(rgRow => rgRow.join('\t')).join('\n');
    }
    textParse(data) {
        const result = [];
        const rows = data.split(/\r\n|\n|\r/);
        for (let y in rows) {
            result.push(rows[y].split('\t'));
        }
        return result;
    }
    htmlParse(data) {
        const result = [];
        const fragment = document.createRange().createContextualFragment(data);
        const table = fragment.querySelector('table');
        if (!table) {
            return null;
        }
        for (const rgRow of Array.from(table.rows)) {
            result.push(Array.from(rgRow.cells).map(cell => cell.innerText));
        }
        return result;
    }
    getData(e) {
        return (e.clipboardData ||
            (window === null || window === void 0 ? void 0 : window.clipboardData));
    }
};

const revogrEditStyleCss = ".revo-drag-icon{width:11px;opacity:0.8}.revo-drag-icon::before{content:\"::\"}.revo-alt-icon{-webkit-mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}.revo-button{position:relative;overflow:hidden;color:#fff;background-color:#4545ff;height:32px;line-height:32px;padding:0 15px;outline:0;border:0;border-radius:7px;box-sizing:border-box;cursor:pointer}.revo-button.green{background-color:#009037}.revo-button.red{background-color:#E0662E}.revo-button:disabled,.revo-button[disabled]{cursor:not-allowed !important;filter:opacity(0.35) !important}.revo-button.outline{border:1px solid #dbdbdb;line-height:30px;background:none;color:#000;box-shadow:none}revo-grid[theme^=dark] .revo-button.outline{border:1px solid #404040;color:#d8d8d8}revogr-edit{display:block;position:absolute;background-color:#fff}revogr-edit input{height:100%;width:100%;box-sizing:border-box}revogr-edit revo-dropdown{height:100%}revogr-edit revo-dropdown.shrink fieldset legend>span{display:none}";

const RevoEdit = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.cellEdit = createEvent(this, "celleditinit", 7);
        this.closeEdit = createEvent(this, "closeedit", 7);
        /**
         * Save on editor close. Defines if data should be saved on editor close.
         */
        this.saveOnClose = false;
        this.currentEditor = null;
        this.preventSaveOnClose = false;
    }
    /**
     * Cancel pending changes flag. Editor will be closed without autosave.
     */
    async cancelChanges() {
        this.preventSaveOnClose = true;
    }
    /**
     * Before editor got disconnected.
     * Can be triggered multiple times before actual disconnect.
     */
    async beforeDisconnect() {
        var _a, _b;
        (_b = (_a = this.currentEditor) === null || _a === void 0 ? void 0 : _a.beforeDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    onAutoSave() {
        var _a, _b, _c;
        this.preventSaveOnClose = true;
        const val = (_b = (_a = this.currentEditor) === null || _a === void 0 ? void 0 : _a.getValue) === null || _b === void 0 ? void 0 : _b.call(_a);
        // For Editor plugin internal usage.
        // When you want to prevent save and use custom save of your own.
        if ((_c = this.currentEditor) === null || _c === void 0 ? void 0 : _c.beforeAutoSave) {
            const canSave = this.currentEditor.beforeAutoSave(val);
            if (canSave === false) {
                return;
            }
        }
        this.onSave(val, true);
    }
    /**
     * Callback triggered when cell editor saved.
     * Closes editor when called.
     * @param preventFocus - if true, editor will not be closed & next cell will not be focused.
     */
    onSave(val, preventFocus) {
        this.preventSaveOnClose = true;
        if (this.editCell) {
            this.cellEdit.emit({
                rgCol: this.editCell.x,
                rgRow: this.editCell.y,
                type: this.editCell.type,
                prop: this.editCell.prop,
                val,
                preventFocus,
            });
        }
    }
    componentWillRender() {
        // Active editor present and not yet closed.
        if (this.currentEditor || !this.column) {
            return;
        }
        this.preventSaveOnClose = false;
        // Custom editor usage.
        // Start with TextEditor (editors/text.tsx) for Custom editor.
        // It can be class or function
        if (this.editor) {
            // if editor is constructible
            if (isEditorCtrConstructible(this.editor)) {
                this.currentEditor = new this.editor(this.column, 
                // save callback
                (e, preventFocus) => {
                    this.onSave(e, preventFocus);
                }, 
                // cancel callback
                focusNext => {
                    this.preventSaveOnClose = true;
                    this.closeEdit.emit(focusNext);
                });
                // if editor is function
            }
            else {
                this.currentEditor = this.editor(this.column, 
                // save callback
                (e, preventFocus) => {
                    this.onSave(e, preventFocus);
                }, 
                // cancel callback
                focusNext => {
                    this.preventSaveOnClose = true;
                    this.closeEdit.emit(focusNext);
                });
            }
            return;
        }
        // Default text editor usage
        this.currentEditor = new TextEditor(this.column, (e, preventFocus) => this.onSave(e, preventFocus));
    }
    componentDidRender() {
        var _a, _b;
        if (!this.currentEditor) {
            return;
        }
        this.currentEditor.element = this.element.firstElementChild;
        (_b = (_a = this.currentEditor).componentDidRender) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    disconnectedCallback() {
        var _a, _b;
        if (this.saveOnClose) {
            // Can not be cancelled by `preventSaveOnClose` prop.
            // Editor requires `getValue` to be able to save.
            if (!this.preventSaveOnClose) {
                this.onAutoSave();
            }
        }
        this.preventSaveOnClose = false;
        if (!this.currentEditor) {
            return;
        }
        (_b = (_a = this.currentEditor).disconnectedCallback) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.currentEditor.element = null;
        this.currentEditor = null;
    }
    render() {
        if (this.currentEditor) {
            this.currentEditor.editCell = this.editCell;
            return (h(Host, { class: EDIT_INPUT_WR }, this.currentEditor.render(h, this.additionalData)));
        }
        return '';
    }
    get element() { return getElement(this); }
};
RevoEdit.style = revogrEditStyleCss;

class RowOrderService {
    constructor(config) {
        this.config = config;
        this.currentCell = null;
        this.previousRow = null;
    }
    /** Drag finished, calculate and apply changes */
    endOrder(e, data) {
        if (this.currentCell === null) {
            return;
        }
        const newRow = this.getCell(e, data);
        // if position changed
        if (newRow.y !== this.currentCell.y) {
            // rgRow dragged out table
            if (newRow.y < 0) {
                newRow.y = 0;
            }
            // rgRow dragged to the top
            else if (newRow.y < this.currentCell.y) {
                newRow.y++;
            }
            this.config.positionChanged(this.currentCell.y, newRow.y);
        }
        this.clear();
    }
    /** Drag started, reserve initial cell for farther use */
    startOrder(e, data) {
        this.currentCell = this.getCell(e, data);
        return this.currentCell;
    }
    move(y, data) {
        const rgRow = this.getRow(y, data);
        // if rgRow same as previous or below range (-1 = 0) do nothing
        if (this.previousRow === rgRow.itemIndex || rgRow.itemIndex < -1) {
            return null;
        }
        this.previousRow = rgRow.itemIndex;
        return rgRow;
    }
    /** Drag stopped, probably cursor outside of document area */
    clear() {
        this.currentCell = null;
        this.previousRow = null;
    }
    /** Calculate cell based on x, y position */
    getRow(y, { el, rows }) {
        const { top } = el.getBoundingClientRect();
        const topRelative = y - top;
        const rgRow = getItemByPosition(rows, topRelative);
        const absolutePosition = {
            itemIndex: rgRow.itemIndex,
            start: rgRow.start + top,
            end: rgRow.end + top,
        };
        return absolutePosition;
    }
    /** Calculate cell based on x, y position */
    getCell({ x, y }, { el, rows, cols }) {
        const { top, left } = el.getBoundingClientRect();
        const topRelative = y - top;
        const leftRelative = x - left;
        const rgRow = getItemByPosition(rows, topRelative);
        const rgCol = getItemByPosition(cols, leftRelative);
        return { x: rgCol.itemIndex, y: rgRow.itemIndex };
    }
}

const OrderEditor = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.rowDragStart = createEvent(this, "rowdragstartinit", 7);
        this.rowDragEnd = createEvent(this, "rowdragendinit", 7);
        this.rowDrag = createEvent(this, "rowdragmoveinit", 7);
        this.rowMouseMove = createEvent(this, "rowdragmousemove", 7);
        this.rowDropped = createEvent(this, "rowdropinit", 7);
        this.rowOrderChange = createEvent(this, "roworderchange", 7);
        this.events = [];
        this.rowMoveFunc = debounce((y) => {
            const rgRow = this.rowOrderService.move(y, this.getData());
            if (rgRow !== null) {
                this.rowDrag.emit(Object.assign(Object.assign({}, rgRow), { rowType: this.rowType }));
            }
        }, 5);
    }
    // #endregion
    // #region Methods
    async dragStart(e) {
        e.originalEvent.preventDefault();
        // extra check if previous ended
        if (this.events.length) {
            this.clearOrder();
        }
        const data = this.getData();
        const cell = this.rowOrderService.startOrder(e.originalEvent, data);
        const pos = this.rowOrderService.getRow(e.originalEvent.y, data);
        const dragStartEvent = this.rowDragStart.emit({
            cell,
            text: DRAGG_TEXT,
            pos,
            event: e.originalEvent,
            rowType: this.rowType,
            model: getSourceItem(this.dataStore, pos.itemIndex),
        });
        if (dragStartEvent.defaultPrevented) {
            return;
        }
        const moveMove = (e) => this.move(e);
        const mouseUp = (e) => this.endOrder(e);
        const mouseLeave = () => this.clearOrder();
        this.events.push({
            name: 'mousemove',
            listener: moveMove,
        }, {
            name: 'mouseup',
            listener: mouseUp,
        }, {
            name: 'mouseleave',
            listener: mouseLeave,
        });
        document.addEventListener('mousemove', moveMove);
        // Action finished inside of the document
        document.addEventListener('mouseup', mouseUp);
        document.addEventListener('mouseleave', mouseLeave);
    }
    async endOrder(e) {
        this.rowOrderService.endOrder(e, this.getData());
        this.clearOrder();
    }
    async clearOrder() {
        this.rowOrderService.clear();
        this.events.forEach(v => document.removeEventListener(v.name, v.listener));
        this.events.length = 0;
        this.rowDragEnd.emit({ rowType: this.rowType });
    }
    // #endregion
    move({ x, y }) {
        this.rowMouseMove.emit({ x, y, rowType: this.rowType });
        this.rowMoveFunc(y);
    }
    connectedCallback() {
        this.rowOrderService = new RowOrderService({
            positionChanged: (from, to) => {
                const dropEvent = this.rowDropped.emit({
                    from,
                    to,
                    rowType: this.rowType,
                });
                if (dropEvent.defaultPrevented) {
                    return;
                }
                this.rowOrderChange.emit(dropEvent.detail);
            },
        });
    }
    getData() {
        return {
            el: this.parent,
            rows: this.dimensionRow.state,
            cols: this.dimensionCol.state,
        };
    }
};

export { Clipboard as revogr_clipboard, RevoEdit as revogr_edit, OrderEditor as revogr_order_editor };
//# sourceMappingURL=revogr-clipboard.revogr-edit.revogr-order-editor.entry.js.map

//# sourceMappingURL=revogr-clipboard_3.entry.js.map